/*
 * generated by Xtext 2.12.0
 */
package edu.uoc.som.jarvis.language.execution.validation

import org.eclipse.xtext.validation.Check
import org.eclipse.emf.ecore.resource.Resource
import static java.util.Objects.isNull
import edu.uoc.som.jarvis.platform.Parameter
import edu.uoc.som.jarvis.execution.ExecutionModel
import edu.uoc.som.jarvis.execution.ExecutionPackage
import edu.uoc.som.jarvis.execution.ActionInstance
import edu.uoc.som.jarvis.utils.ImportRegistry
import edu.uoc.som.jarvis.common.ContextAccess
import edu.uoc.som.jarvis.language.execution.ExecutionUtils
import edu.uoc.som.jarvis.common.CommonPackage
import edu.uoc.som.jarvis.common.OperationCall
import java.util.Collection
import edu.uoc.som.jarvis.intent.Context
import edu.uoc.som.jarvis.common.StringLiteral

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ExecutionValidator extends AbstractExecutionValidator {

	@Check
	def checkExecutionModelValidImports(ExecutionModel model) {
		model.imports.forEach [ i |
			println("Checking import " + i)
			var Resource platformResource = ImportRegistry.getInstance.getOrLoadImport(i)
			if (isNull(platformResource)) {
				error('Platform ' + i + "does not exist", ExecutionPackage.Literals.EXECUTION_MODEL__IMPORTS)
			}
		]
	}

	@Check
	def checkValidActionInstance(ActionInstance actionInstance) {
		val actionParameters = actionInstance.action.parameters;
		val actionInstanceParameters = actionInstance.values.map[v|v.parameter]
		for (Parameter p : actionParameters) {
			if (!actionInstanceParameters.contains(p)) {
				println('The parameter ' + p.key + ' is not set in the action instance')
				error('The parameter ' + p.key + ' is not set in the action instance',
					ExecutionPackage.Literals.ACTION_INSTANCE__VALUES)
			}
		}
	}

	@Check
	def checkValidContextAccess(ContextAccess contextAccess) {
		val ExecutionModel executionModel = ExecutionUtils.getContainingExecutionModel(contextAccess)
		var boolean found = ExecutionUtils.getOutContextsFromImports(executionModel).map[name].toSet.contains(
			contextAccess.contextName)
		if (!found) {
			println("The context " + contextAccess.contextName + " is undefined")
			error("The context " + contextAccess.contextName + " is undefined",
				CommonPackage.Literals.CONTEXT_ACCESS__CONTEXT_NAME)
		}
	}

	@Check
	def checkValidContextParameterAccess(OperationCall operationCall) {
		if (operationCall.source instanceof ContextAccess && operationCall.name.equals("get")) {
			if (operationCall.args.size == 1) {
				if (operationCall.args.get(0) instanceof StringLiteral) {
					val ContextAccess contextAccess = operationCall.source as ContextAccess
					val String arg = (operationCall.args.get(0) as StringLiteral).value
					val ExecutionModel executionModel = ExecutionUtils.getContainingExecutionModel(operationCall)
					var boolean found = ExecutionUtils.getOutContextsFromImports(executionModel).filter [
						name.equals(contextAccess.contextName)
					].map [parameters.map[name]].flatten.toSet.contains(arg)
					if (!found) {
						error("Parameter " + arg + " is not defined in context " + contextAccess.contextName,
							CommonPackage.Literals.OPERATION_CALL__ARGS)
					}
				} else {
					// do nothing, it may be a variable holding a name
				}
			} else {
				error("The method get on a stored context accepts a single element of type String",
					CommonPackage.Literals.OPERATION_CALL__ARGS)
			}
		}
	}
}
